# cocos框架和matter.js融合
> 以下所有函数均在`game.js`中定义，在`TLayer.js`中调用

## 一、函数定义
1. 引入
> 初始化matter，创建物理引擎世界
```js
initMatter:function(){
    var Engine = Matter.Engine;
    game.Render = Matter.Render;
    game.Composite = Matter.Composite;
    game.Runner = Matter.Runner;
    game.Bodies = Matter.Bodies;

    game.runner = game.Runner.create();
    game.engine = Engine.create();
    game.world = game.engine.world;
  
    game.render = game.Render.create({
        element: document.getElementById('world'),
        engine: game.engine
    });
},
```

2. 添加物体
> 创建物体，并且加入物体数组中，方便之后放入物理引擎世界
```js
addBody:function(style,options){
    var body;
    if(style == 'circle'){
        body = game.Bodies.circle(options.x,options.y,options.radius)
    }else if(style == 'polygon'){
        body = game.Bodies.polygon(options.x,options.y,options.sides,options.radius)
    }else if(style == 'rectangle'){
        body = game.Bodies.rectangle(options.x,options.y,options.width,options.height)
    }else if(style == 'trapezoid'){
        body = game.Bodies.trapezoid(options.x,options.y,options.width,options.height,options.slope)
    }else if(style == 'Vertices'){
        body = game.Bodies.fromVertices(options.x,options.y,options.vertexSets)
    }
    if(options.isStatic){
        body.isStatic = true;//判断物体是不是刚体
    }
    this.bodyList.push(body);
    return body;
},
```

3. 将物体添加进物理引擎世界并运行物理引擎

```js
addToWorld:function(callback){
    game.Composite.add(game.world, game.bodyList);
    callback && callback();
},
startMatter:function(){
    game.Runner.run(game.runner, game.engine);
}
```

## 二、函数调用



### 案例展示

```js
var name1 = this.getChildByName('name_1');
name1.visible = true;
name1.anchorX=0;
name1.anchorY=1;

var name2 = this.getChildByName('name_2');
name2.visible = true;
name2.anchorX=0;
name2.anchorY=1;

//创建墙
var ground = game['addBody']('rectangle',{
    x:375,
    y:1180,
    width:750,
    height:60,
    isStatic:true
})

//创建物体
var boxA = game['addBody']('rectangle',{
    x:400,
    y:200,
    width:80,
    height:80//根据cocos中物体的信息进行修改
})
var boxB = game['addBody']('rectangle',{
    x:350,
    y:100,
    width:80,
    height:80
})
//添加物体到物理引擎世界，并且开始运行
game['addToWorld'](function(){
    game['startMatter']();

})


//在回调函数中改变物体的位置和旋转角度，注意matter中物体的旋转角度不是deg需要换算
this.updateCallback = function(){

    var x0 = boxA.vertices[0].x
    var y0 = boxA.vertices[0].y


    var x1 = boxB.vertices[0].x
    var y1 = boxB.vertices[0].y

    name1.x = x0;
    name1.y = 1240-y0;
    name1.rotation = boxA.angle*180/Math.PI;

    name2.x = x1;
    name2.y = 1240-y1;
    name2.rotation = boxB.angle*180/Math.PI;

}

this.scheduleUpdate();
```



## 三、多边形图形

1. 获取多边形坐标点数组
通过texturePacker工具，参数如下图：
<img width="335" alt="image" src="https://user-images.githubusercontent.com/70060430/167333337-f6bedc05-6221-48b8-a56c-75c544131556.png">

同时将高级设置中的**修剪边距**设为0，获取坐标信息放入cocos框架中

2. 处理坐标点参数
通过`Matter.Vertices.centre`获取不规则图形的重心点，然后通过坐标换算得出锚点，如下
```js
var boxA = game['addBody']('Vertices',{
    x:name1.x,
    y:1240-name1.y,
    vertexSets:ver
})


var info = game.getCenter(vertices);


var c = game['Vertices'].centre(ver);
console.log(c);//如何将重心点变为物体锚点

anchorX = c.x/(info.max_x-info.min_x);
anchorY = (info.max_y-c.y)/(info.max_x-info.min_x);//物理引擎中原点在左上，这里需要换成左下原点

console.log(anchorX,anchorY);
name1.anchorX = anchorX;
name1.anchorY = anchorY;
```

ps:使用函数`game.getCenter`时，需要放入坐标数组列表。计算锚点时注意位置换算（cocos原点是左下，matter中是左上）。
